using System.Collections;
using System.Collections.Generic;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

[ExecuteInEditMode]
[RequireComponent(typeof(MeshFilter))]
[RequireComponent(typeof(MeshRenderer))]
public class PlantGenerator : MonoBehaviour {
    // The mesh to be generated by this plant generator
    public Mesh generatedMesh;
    
    // Temp: A curve for petals
    public AnimationCurve petalCurve = AnimationCurve.EaseInOut(0.0f, 0.0f, 1.0f, 1.0f);
    public AnimationCurve upCurve = AnimationCurve.EaseInOut(0.0f, 0.0f, 1.0f, 1.0f);
    public AnimationCurve widthCurve = AnimationCurve.EaseInOut(0.0f, 0.0f, 1.0f, 1.0f);
    public AnimationCurve lengthCurve = AnimationCurve.EaseInOut(0.0f, 0.0f, 1.0f, 1.0f);
    public AnimationCurve twistCurve = AnimationCurve.EaseInOut(0.0f, 0.0f, 1.0f, 1.0f);

    // FOR EASE OF USE: A bool that actually regenerates the mesh whenever you click it. May be removed later
    public bool doRegenerate    = true;
    private bool lastRegenerate = false;

    // FOR EASE OF USE: A list of editable points in 3D space
    public Vector3[] editablePoints = new Vector3[1];

	// Use this for initialization
	void Awake() {
		if (!generatedMesh)
        {
            generatedMesh = new Mesh();
        }
	}
	
	// Update is called once per frame
	void Update () {
        // todo remove this
        doRegenerate = !doRegenerate;
		if (doRegenerate != lastRegenerate)
        {
            Regenerate();

            lastRegenerate = doRegenerate;
        }
	}

    // Regenerates the mesh from the ground up
    void Regenerate()
    {
        // Create a new GenMesh to begin building the mesh
        GenMesh mesh = new GenMesh();

        // and a petal, for good measure
        Vector3 s = editablePoints.Length > 0 ? editablePoints[0] : Vector3.zero, e = editablePoints.Length > 1 ? editablePoints[1] : Vector3.zero;
        mesh += new GenTube(Vector3.zero, s - Vector3.zero)
        {
            radius = 0.3f,
            widthCurve = widthCurve,
            lengthCurve = lengthCurve,
            upCurve = upCurve,
            twistCurve = twistCurve,
            numSegmentVertices = 64,
        };
        mesh += new GenSymmetrise(new GenPetal(s, e - s, 0.3f, petalCurve, 128), 8, s, Vector3.up);
        
        // Copy the GenMesh contents to the mesh
        mesh.CopyToUnityMesh(generatedMesh);

        // Transfer new mesh contents to filter
        generatedMesh.RecalculateNormals();
        GetComponent<MeshFilter>().sharedMesh = generatedMesh;
    }

    // Regenerates all plants when the script is changed
    [UnityEditor.Callbacks.DidReloadScripts]
    private static void OnScriptsReloaded()
    {
        foreach (PlantGenerator generator in FindObjectsOfType<PlantGenerator>())
        {
            generator.Regenerate();
        }
    }
}